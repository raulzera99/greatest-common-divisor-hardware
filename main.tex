\documentclass[a4paper,11pt]{article} %Selecionando a classe que gera artigos.

\input{preambulo} %Pacotes principais

\fancypagestyle{empty}{%
\fancyhf{}% clear all header and footer fields
\fancyfoot[L]{Linguagem e Descrição de Hardware} % except the center
\fancyfoot[R]{\thepage} % except the center
% \fancyfoot[R]{ISSN: 2178-9959} % except the center
\renewcommand{\headrulewidth}{0pt}%
\renewcommand{\footrulewidth}{0pt}%
}
\pagestyle{empty}

\begin{document} %Begin Inicia o Documento

\input{cabecalho} %Alterar Título, autores, e apagar tabela !

\begin{center}
    \tableofcontents %Gera o sumário
\end{center}

\newpage

%----------------------------------------TEXTOS-------------------------------------------------%

\vspace{0.5cm}
\noindent\textbf{RESUMO}: 
Este artigo apresenta a implementação do algoritmo para cálculo do 
Greatest Common Divisor (GCD) em hardware, 
utilizando uma abordagem de Control e Datapath. 
Serão abordadas as principais etapas de desenvolvimento, 
incluindo a descrição do algoritmo em linguagem C, 
a modelagem dos módulos de controle e datapath em Verilog, 
e a simulação e validação do sistema.

\vspace{0.5cm}
\noindent\textbf{PALAVRAS-CHAVE}: 
GCD; Greatest Common Divisor; Hardware Description Language; Control; Datapath.

\vspace{0.5cm}
 \begin{center}
 \textbf{Greatest Common Divisor - (GCD)}
 \end{center}

\noindent\textbf{ABSTRACT}: 
This paper presents the implementation of the Greatest Common Divisor (GCD) 
algorithm in hardware, using a Control and Datapath approach. 
The main development steps will be addressed, 
including the description of the algorithm in C language, 
the modeling of control and datapath modules in Verilog, 
and the system simulation and validation.

\vspace{0.5cm}
\noindent\textbf{KEYWORDS}: GCD; Greatest Common Divisor; Hardware Description Language; Control; Datapath.

\section{Introdução}

O Greatest Common Divisor (GCD) é um problema clássico da teoria dos números, 
com aplicações em diversas áreas da computação. 
Este trabalho baseia-se nas notas de aula da disciplina CSE 141L: 
Introduction to Computer Architecture Lab, 
ministrada na Universidade da Califórnia. 
O objetivo é desenvolver uma implementação eficiente do GCD 
utilizando linguagem de descrição de hardware.

O cálculo do GCD é frequentemente utilizado em algoritmos de criptografia, 
compressão de dados e outros campos onde operações matemáticas eficientes 
são essenciais. 
Este projeto visa criar um design em hardware que maximize a 
eficiência dessas operações.

As referências devem estar citadas no trabalho conforme a sua forma de citação, 
como por exemplo \cite{alves}, \cite{galvani} e \cite{national_instruments} 
ou em Pandorfi, et al, (2007). 
Na seção Referências devem ser listadas em ordem alfabética \cite{pandorfi}.

\section{Fundamentação Teórica}
% Esta seção deve apresentar os conceitos teóricos fundamentais para o entendimento do GCD e sua relevância em computação. Aborde os princípios matemáticos e as aplicações típicas do GCD.

\subsection{Conceitos Básicos de GCD}
% Definição do Greatest Common Divisor (GCD) e explicação da importância deste conceito na teoria dos números. Mencionar brevemente como o GCD é utilizado na simplificação de frações, criptografia, e outras áreas da matemática aplicada.

\subsection{Algoritmo de Euclides}
% Explicação do Algoritmo de Euclides, um dos métodos mais eficientes para calcular o GCD. Detalhar o funcionamento do algoritmo e discutir sua complexidade computacional. 

\subsection{Aplicações do GCD em Computação}
% Descrição das aplicações práticas do GCD em computação, como em criptografia (ex.: RSA), compressão de dados e sistemas de controle. Discutir porque o GCD é uma operação relevante em hardware.

\section{Desenho de Arquitetura}
% Nesta seção, descreva a arquitetura utilizada para a implementação do GCD em hardware. Inclua uma visão geral dos módulos e suas interações.

\subsection{Partição em Módulos}
% Detalhamento da divisão do projeto em módulos de Control e Datapath. Explicar o papel de cada módulo no sistema e como eles se comunicam. Pode incluir um diagrama de blocos para ilustrar.

\subsection{Diagramas de Blocos}
% Apresentar diagramas de blocos que representem a arquitetura do GCD, mostrando como os diferentes componentes se conectam e interagem. Explicar o fluxo de dados entre os módulos.

\section{Desenvolvimento e Implementação}

Os materiais e métodos utilizados no desenvolvimento da pesquisa incluem a descrição do algoritmo em C, a modelagem dos módulos de controle e datapath em Verilog, e a simulação utilizando o ambiente Intel QuestaSim.

\subsection{Descrição do Algoritmo em C}

O algoritmo para cálculo do GCD pode ser implementado de diversas maneiras. Abaixo, apresentamos uma implementação em linguagem C:

\begin{verbatim}
int GCD(int inA, int inB) {
    int swap;
    int done = 0;
    int A = inA;
    int B = inB;
    while (!done) {
        if (A < B) {
            swap = A;
            A = B;
            B = swap;
        } else if (B != 0) {
            A = A - B;
        } else {
            done = 1;
        }
    }
    return A;
}
\end{verbatim}

\subsection{Modelagem em Verilog}

A implementação do GCD em hardware envolve a criação de módulos para o controle e o datapath. O datapath lida com a movimentação e transformação dos dados, enquanto o módulo de controle gerencia as operações de controle.

\subsubsection{Módulo Datapath}
\begin{verbatim}
module GCDdatapath#( parameter W=16 )
(
    input clk,
    input [W-1:0] operand_A,
    input [W-1:0] operand_B,
    output [W-1:0] result_data,
    input A_ld,
    input B_ld,
    input [1:0] A_sel,
    input B_sel,
    output B_zero,
    output A_lt_B,
    output [W-1:0] A_chk, B_chk, sub_chk, A_mux_chk, B_mux_chk
);

    wire [W-1:0] A;
    wire [W-1:0] B;
    wire [W-1:0] sub_out;
    wire [W-1:0] A_mux_out;
    wire [W-1:0] B_mux_out;

    Mux3#(W) A_mux
    (.in0 (operand_A),
    .in1 (sub_out),
    .in2 (B),
    .sel (A_sel),
    .out (A_mux_out) );

    register#(W) A_reg
    (.clk (clk),
    .d (A_mux_out),
    .en (A_ld),
    .q (A) );

    Mux2#(W) B_mux
    (.in0 (A),
    .in1 (operand_B),
    .sel (B_sel),
    .out (B_mux_out) );

    register#(W) B_reg
    (.clk (clk),
    .d (B_mux_out),
    .en (B_ld),
    .q (B) );

    assign B_zero = (B==0);
    assign A_lt_B = (A < B);
    assign sub_out = A - B;
    assign result_data = A;
    // send checking signals only for debugging purposes
    assign A_chk = A;
    assign B_chk = B;
    assign sub_chk = sub_out;
    assign A_mux_chk = A_mux_out;
    assign B_mux_chk = B_mux_out;
endmodule
\end{verbatim}

\subsubsection{Módulo Controle}
\begin{verbatim}
module GCDcontrol(
    input input_available,
    output reg idle,
    input clk, reset,
    output reg A_ld, B_sel, B_ld,
    output reg [1:0] A_sel,
    input B_zero, A_lt_B,
    output reg result_rdy,
    input result_taken,
    output [1:0] State
);

    // States naming
    localparam WAIT = 2'd0;
    localparam CALC = 2'd1;
    localparam DONE = 2'd2;

    // Constants naming for A_mux selector
    localparam A_SEL_IN = 2'b00;
    localparam A_SEL_SUB = 2'b01;
    localparam A_SEL_B = 2'b10;
    localparam A_SEL_X = 2'b11;
    // Constants naming for B_mux selector
    localparam B_SEL_A = 1'b0;
    localparam B_SEL_IN = 1'b1;
    localparam B_SEL_X = 1'bx;

    reg [1:0] CurrentState, NextState;

    always @(posedge clk or posedge reset)  
    begin 
        if (reset) 
            CurrentState <= WAIT;
        else 
            CurrentState <= NextState; 
    end 

    always @(CurrentState)
    begin
        // default is to stay in the same state
        NextState <= CurrentState;
        case ( CurrentState )
            WAIT :
                if ( input_available )
                    NextState <= CALC;
            CALC :
                if ( B_zero )
                    NextState <= DONE;
            DONE :
                if ( result_taken )
                    NextState <= WAIT;
        endcase
    end 

    always @( * )
    begin
        // Default control signals
        A_sel <= A_SEL_X;
        A_ld <= 1'b0;
        B_sel <= B_SEL_X;
        B_ld <= 1'b0;
        idle <= 1'b0; 
        result_rdy = 1'b0;

        case ( CurrentState )
            WAIT :
                begin
                    idle <= 1'b1; 
                    if(input_available)begin
                        A_sel <= A_SEL_IN;
                        B_sel <= B_SEL_IN;
                        A_ld <= 1'b1;   
                        B_ld <= 1'b1;
                    end
                end
            CALC :
                if ( A_lt_B )begin
                    A_sel <= A_SEL_B;
                    B_sel <= B_SEL_A;
                    A_ld <= 1'b1;
                    B_ld <= 1'b1;
                end
                else if ( !B_zero )begin
                    A_sel <= A_SEL_SUB;
                    A_ld <= 1'b1;
                end
            DONE : 
                result_rdy <= 1'b1;
        endcase
    end

    assign State = CurrentState; 
endmodule
\end{verbatim}

\section{Máquina de Estados Finitos (FSM)}
% Nesta seção, discuta a FSM utilizada para controlar o Datapath.

\subsection{Descrição dos Estados}
% Descrever os diferentes estados da FSM, explicando o que ocorre em cada estado e como as transições entre estados são gerenciadas. Pode incluir um diagrama de estados para visualização.

\subsection{Implementação da FSM}
% Discutir como a FSM foi implementada em Verilog, incluindo os desafios encontrados durante o desenvolvimento e como foram superados. Explicar a lógica de transição e os sinais de controle envolvidos.

\section{Simulações e Verificação}

Para validar a implementação, foi realizada a simulação dos módulos utilizando o ambiente Intel QuestaSim. A Figura \ref{fig:simulacao} mostra a simulação do módulo GCD.

\subsection{Simulação do módulo GCD}
\begin{figure}[ht]
\centering
% \includegraphics[width=10cm,angle=0]{simulacao_gcd.png}
\caption{Simulação do módulo GCD}
\label{fig:simulacao}
\end{figure}

Os resultados da simulação confirmam que o design do GCD em hardware funciona conforme esperado. O módulo datapath executa corretamente as operações de subtração e troca, enquanto o módulo de controle gerencia os estados do sistema de maneira eficiente.

\subsection{Ambiente de Simulação}
% Descrever o ambiente de simulação utilizado, como o Intel QuestaSim. Explicar como os testes foram configurados e quais aspectos do sistema foram verificados.

\subsection{Resultados da Simulação}
% Apresentar os resultados obtidos durante a simulação. Incluir gráficos ou capturas de tela que mostrem a operação do GCD. Discutir se os resultados atenderam às expectativas e os objetivos do projeto.

\section{Otimizações e Melhorias Futuras}

Mesmo se tratando de um algoritmo relativamente simples, o design do GCD em hardware pode ser otimizado e expandido para atender a requisitos mais exigentes. Nesta seção, discutiremos possíveis melhorias no design, como a implementação de pipelining no datapath e a expansão do sistema para suportar operações mais complexas.




\subsection{Otimização do Datapath}
% Sugerir melhorias no Datapath, como a implementação de pipelining para aumentar a eficiência. Discutir possíveis modificações que poderiam ser feitas para melhorar o desempenho geral do sistema.
Uma possível otimização é a implementação de pipelining no datapath. Isso permitiria que várias operações de subtração e troca fossem executadas em paralelo, aumentando a eficiência do sistema. Além disso, o uso de registradores adicionais poderia reduzir o número de operações de leitura e escrita na memória, melhorando ainda mais o desempenho.


\subsubsection{Implemetação do Pipelining}
O pipelining é uma técnica fundamental para aumentar a eficiência e o desempenho de sistemas de processamento. Ao aplicar pipelining no datapath do algoritmo GCD, podemos dividir o processo de cálculo em estágios distintos que podem ser executados em paralelo, reduzindo o tempo total necessário para a execução e aumentando o throughput \cite{Hennessy2017}.

\begin{enumerate}
    \item \textbf{Divisão do Algoritmo GCD em Estágios}



Para o algoritmo GCD, que geralmente é implementado usando o Algoritmo de Euclides, podemos dividir o processamento em vários estágios:

\begin{itemize}
    \item \textbf{Estágio 1:} Cálculo do Resto - Calcula o resto da divisão entre dois números.
    \item \textbf{Estágio 2:} Atualização dos Valores - Atualiza os valores dos números com base no resto calculado.
    \item \textbf{Estágio 3:} Verificação da Condição de Parada - Verifica se o resto é zero, o que indica que o cálculo está concluído \cite{Knuth1997}.
\end{itemize}

 \item \textbf{Implementação do Pipelining}

A implementação do pipelining para o GCD pode ser feita da seguinte maneira:

\begin{itemize}
    \item \textbf{Pipelide de Estágios}: Cada estágio do pipeline pode ser otimizado para realizar sua tarefa específica simultaneamente com outros estágios. Por exemplo, enquanto um estágio calcula o resto, outro pode estar atualizando os valores ou verificando a condição de parada.
    \item \textbf{Buffer de Pipeline}: Adicionar buffers entre os estágios para armazenar dados temporários e permitir que o processamento continue sem interrupções.
    \item \textbf{Controle de Fluxo}: Implementar mecanismos de controle para gerenciar a sincronização entre os estágios e garantir que cada estágio receba os dados no momento certo \cite{Patterson2013}.
\end{itemize}

\end {enumerate}

\subsubsection{Benefícios do Pipelining}

\begin{enumerate}
    \item \textbf{Redução do Tempo de Execução} Ao dividir o trabalho entre vários estágios e processar diferentes partes do algoritmo simultaneamente, o tempo total para concluir a operação de GCD é reduzido.
    \item \textbf{Aumento do Throughput:} A capacidade de processar múltiplos cálculos de GCD em paralelo pode aumentar o throughput geral do sistema \cite{Harris2010}.
    \item \textbf{Paralelismo de dados:}
        \begin{itemize}
            \item \textbf{Execução Paralela:} Implementar execução paralela para processar múltiplos pares de números simultaneamente. Isso pode ser feito usando múltiplos pipelines ou unidades de processamento.
        \end{itemize}
        \item \textbf{Otimização de Hardware:} 
            \begin{itemize}
                \item \textbf{Uso de Recursos Específicos:} Utilizar unidades de hardware específicas para operações matemáticas, como divisores de alto desempenho, para acelerar o cálculo do resto.
                \item \textbf{Redução de Latência:} Minimizar a latência entre as operações utilizando técnicas de otimização de circuito.
                \item \textbf{Eficiência Energética:} Implementar técnicas para reduzir o consumo de energia, como a otimização do design do circuito e o uso eficiente dos recursos de hardware.
            \end{itemize}
    \item \textbf{Algoritmos Alternativos:}
        \begin{itemize}
            \item \textbf{Exploração de Algoritmos:} Explorar algoritmos alternativos para o cálculo do GCD que possam oferecer melhorias em termos de eficiência e velocidade \cite{Bressoud2011}.
        \end{itemize}
\end{enumerate}

% Redução do Tempo de Execução: Ao dividir o trabalho entre vários estágios e processar diferentes partes do algoritmo simultaneamente, o tempo total para concluir a operação de GCD é reduzido.
% Aumento do Throughput: A capacidade de processar múltiplos cálculos de GCD em paralelo pode aumentar o throughput geral do sistema \cite{Harris2010}.
% Possíveis Modificações para Melhorar o Desempenho
% Além do pipelining, outras modificações podem ser feitas para melhorar o desempenho geral do sistema:

% 1. Paralelismo de Dados

% Execução Paralela: Implementar execução paralela para processar múltiplos pares de números simultaneamente. Isso pode ser feito usando múltiplos pipelines ou unidades de processamento.
% 2. Otimização de Hardware

% Uso de Recursos Específicos: Utilizar unidades de hardware específicas para operações matemáticas, como divisores de alto desempenho, para acelerar o cálculo do resto.
% Redução de Latência: Minimizar a latência entre as operações utilizando técnicas de otimização de circuito.
% 3. Eficiência Energética

% Otimização de Consumo de Energia: Implementar técnicas para reduzir o consumo de energia, como a otimização do design do circuito e o uso eficiente dos recursos de hardware.
% 4. Algoritmos Alternativos

% Exploração de Algoritmos: Explorar algoritmos alternativos para o cálculo do GCD que possam oferecer melhorias em termos de eficiência e velocidade \cite{Bressoud2011}.
\paragraph{Conclusão :}
A aplicação de pipelining e outras técnicas de otimização pode significativamente melhorar a eficiência e o desempenho do datapath para o algoritmo GCD. Ao dividir o trabalho em estágios e implementar estratégias para reduzir latência e aumentar o throughput, podemos alcançar um sistema mais rápido e eficiente.


\subsection{Expansão do Design para Sistemas Maiores}
% Discutir como o design do GCD poderia ser expandido para se integrar com sistemas maiores ou suportar operações mais complexas. Propor ideias para a adaptação do módulo para novas aplicações.

Outra melhoria futura seria a expansão do design para suportar sistemas maiores ou operações mais complexas. Por exemplo, o módulo GCD poderia ser integrado a um processador ou coprocessador específico para criptografia. Isso exigiria a adaptação do módulo para se comunicar com outros componentes do sistema e lidar com algoritmos mais avançados.




\section{Discussão sobre Integração com Sistemas Maiores e Otimização do Datapath}
% Explorar como o módulo GCD poderia ser integrado em sistemas mais complexos, como processadores ou coprocessadores específicos para criptografia. Discutir os desafios de integração e as vantagens dessa abordagem.

É importante ressaltar que essas otimizações e melhorias futuras podem trazer desafios adicionais, como a complexidade do design e a necessidade de recursos adicionais. Portanto, é necessário realizar uma análise cuidadosa dos requisitos e restrições do sistema antes de implementar essas melhorias.


Em resumo, as otimizações e melhorias futuras no design do algoritmo GCD em hardware são uma área de interesse contínua para estudantes de Engenharia de Computação. Com a combinação certa de conhecimento teórico e prático, é possível criar soluções eficientes e inovadoras que atendam às demandas cada vez maiores da computação moderna.


\section{Conclusões}

Neste artigo, apresentamos a implementação do algoritmo GCD em hardware, detalhando a modelagem dos módulos de controle e datapath em Verilog. A simulação mostrou que a abordagem utilizada é eficiente e atende aos requisitos do projeto. Futuras melhorias podem incluir a otimização do datapath e a integração com outros módulos de um sistema maior.

%Referências Bibliográficas
\bibliography{bibliografia.bib}
%\printbibliography[title={REFERÊNCIAS}]
%\printbibliography{bibliografia}

\end{document}
