\documentclass[a4paper,11pt]{article} %Selecionando a classe que gera artigos.

\input{preambulo} %Pacotes principais

\fancypagestyle{empty}{%
\fancyhf{}% clear all header and footer fields
\fancyfoot[L]{Linguagem e Descrição de Hardware} % except the center
\fancyfoot[R]{\thepage} % except the center
% \fancyfoot[R]{ISSN: 2178-9959} % except the center
\renewcommand{\headrulewidth}{0pt}%
\renewcommand{\footrulewidth}{0pt}%
}
\pagestyle{empty}

\begin{document} %Begin Inicia o Documento

\input{cabecalho} %Alterar Título, autores, e apagar tabela !

\begin{center}
    \tableofcontents %Gera o sumário
\end{center}

\newpage

%----------------------------------------TEXTOS-------------------------------------------------%

\vspace{0.5cm}
\noindent\textbf{RESUMO}: 
Este artigo apresenta a implementação do algoritmo para cálculo do 
Greatest Common Divisor (GCD) em hardware, 
utilizando uma abordagem de Control e Datapath. 
Serão abordadas as principais etapas de desenvolvimento, 
incluindo a descrição do algoritmo em linguagem C, 
a modelagem dos módulos de controle e datapath em Verilog, 
e a simulação e validação do sistema.

\vspace{0.5cm}
\noindent\textbf{PALAVRAS-CHAVE}: 
GCD; Greatest Common Divisor; Hardware Description Language; Control; Datapath.

\vspace{0.5cm}
 \begin{center}
 \textbf{Greatest Common Divisor - (GCD)}
 \end{center}

\noindent\textbf{ABSTRACT}: 
This paper presents the implementation of the Greatest Common Divisor (GCD) 
algorithm in hardware, using a Control and Datapath approach. 
The main development steps will be addressed, 
including the description of the algorithm in C language, 
the modeling of control and datapath modules in Verilog, 
and the system simulation and validation.

\vspace{0.5cm}
\noindent\textbf{KEYWORDS}: GCD; Greatest Common Divisor; Hardware Description Language; Control; Datapath.

\section{Introdução}

O Greatest Common Divisor (GCD) é um problema clássico da teoria dos números, 
com aplicações em diversas áreas da computação. 
Este trabalho baseia-se nas notas de aula da disciplina CSE 141L: 
Introduction to Computer Architecture Lab, 
ministrada na Universidade da Califórnia. 
O objetivo é desenvolver uma implementação eficiente do GCD 
utilizando linguagem de descrição de hardware.

O cálculo do GCD é frequentemente utilizado em algoritmos de criptografia, 
compressão de dados e outros campos onde operações matemáticas eficientes 
são essenciais. 
Este projeto visa criar um design em hardware que maximize a 
eficiência dessas operações.

As referências devem estar citadas no trabalho conforme a sua forma de citação, 
como por exemplo \cite{alves}, \cite{galvani} e \cite{national_instruments} 
ou em Pandorfi, et al, (2007). 
Na seção Referências devem ser listadas em ordem alfabética \cite{pandorfi}.

\section{Fundamentação Teórica}
% Esta seção deve apresentar os conceitos teóricos fundamentais para o entendimento do GCD e sua relevância em computação. Aborde os princípios matemáticos e as aplicações típicas do GCD.

\subsection{Conceitos Básicos de GCD}
% Definição do Greatest Common Divisor (GCD) e explicação da importância deste conceito na teoria dos números. Mencionar brevemente como o GCD é utilizado na simplificação de frações, criptografia, e outras áreas da matemática aplicada.

\subsection{Algoritmo de Euclides}
% Explicação do Algoritmo de Euclides, um dos métodos mais eficientes para calcular o GCD. Detalhar o funcionamento do algoritmo e discutir sua complexidade computacional. 

\subsection{Aplicações do GCD em Computação}
% Descrição das aplicações práticas do GCD em computação, como em criptografia (ex.: RSA), compressão de dados e sistemas de controle. Discutir porque o GCD é uma operação relevante em hardware.


\section{Desenho de Arquitetura}
% Nesta seção, descreva a arquitetura utilizada para a implementação do GCD em hardware. Inclua uma visão geral dos módulos e suas interações.
Esta seção descreve a arquitetura do sistema, incluindo a partição em módulos de controle e datapath, e os diagramas de blocos que ilustram a interação entre os componentes.

\subsection{Partição em Módulos}
% Detalhamento da divisão do projeto em módulos de Control e Datapath. 
% Explicar o papel de cada módulo no sistema e como eles se comunicam. 
% Pode incluir um diagrama de blocos para ilustrar.
A arquitetura do sistema GCD foi dividida em dois módulos principais: Control e Datapath.
Esta divisão permite uma clara separação de responsabilidades, permite 
uma maior modularidade, 
facilita a implementação, manutenção e expansão do sistema.

\subsubsection{Módulo de Controle}
O módulo de controle gerencia o fluxo de dados e 
as transições entre os estados do sistema. 

\subsubsection{Módulo Datapath}
O Datapath é responsável pelas operações aritméticas, 
como a subtração e a comparação dos valores de entrada.

\subsection{Diagramas de Blocos}
% Apresentar diagramas de blocos que representem a arquitetura do GCD, mostrando como os diferentes componentes se conectam e interagem. Explicar o fluxo de dados entre os módulos.
A figura a seguir ilustra a arquitetura top-level do sistema GCD,
mostrando todos as inputs e outputs como se fossem um único bloco.

\begin{figure}[ht]
\begin{center} 
\label{fig:top_level}
\caption{Diagrama de Blocos do Sistema GCD}
\includegraphics[width=10cm,angle=0]{imgs/diagram_block_top_level.png}
\textbf{Fonte:} Elaborado pelos autores.
\end{center}
\end{figure}

\section{Desenvolvimento e Implementação}

Os materiais e métodos utilizados no desenvolvimento da pesquisa incluem a descrição do algoritmo em C, a modelagem dos módulos de controle e datapath em Verilog, e a simulação utilizando o ambiente Intel QuestaSim.

\subsection{Descrição do Algoritmo em C}

O algoritmo para cálculo do GCD pode ser implementado de diversas maneiras. Abaixo, apresentamos uma implementação em linguagem C:

\begin{verbatim}
int GCD(int inA, int inB) {
    int swap;
    int done = 0;
    int A = inA;
    int B = inB;
    while (!done) {
        if (A < B) {
            swap = A;
            A = B;
            B = swap;
        } else if (B != 0) {
            A = A - B;
        } else {
            done = 1;
        }
    }
    return A;
}
\end{verbatim}

\subsection{Modelagem em Verilog}

A implementação do GCD em hardware envolve a criação de módulos para o controle e o datapath. O datapath lida com a movimentação e transformação dos dados, enquanto o módulo de controle gerencia as operações de controle.

\subsubsection{Módulo Datapath}
\begin{verbatim}
module GCDdatapath#( parameter W=16 )
(
    input clk,
    input [W-1:0] operand_A,
    input [W-1:0] operand_B,
    output [W-1:0] result_data,
    input A_ld,
    input B_ld,
    input [1:0] A_sel,
    input B_sel,
    output B_zero,
    output A_lt_B,
    output [W-1:0] A_chk, B_chk, sub_chk, A_mux_chk, B_mux_chk
);

    wire [W-1:0] A;
    wire [W-1:0] B;
    wire [W-1:0] sub_out;
    wire [W-1:0] A_mux_out;
    wire [W-1:0] B_mux_out;

    Mux3#(W) A_mux
    (.in0 (operand_A),
    .in1 (sub_out),
    .in2 (B),
    .sel (A_sel),
    .out (A_mux_out) );

    register#(W) A_reg
    (.clk (clk),
    .d (A_mux_out),
    .en (A_ld),
    .q (A) );

    Mux2#(W) B_mux
    (.in0 (A),
    .in1 (operand_B),
    .sel (B_sel),
    .out (B_mux_out) );

    register#(W) B_reg
    (.clk (clk),
    .d (B_mux_out),
    .en (B_ld),
    .q (B) );

    assign B_zero = (B==0);
    assign A_lt_B = (A < B);
    assign sub_out = A - B;
    assign result_data = A;
    // send checking signals only for debugging purposes
    assign A_chk = A;
    assign B_chk = B;
    assign sub_chk = sub_out;
    assign A_mux_chk = A_mux_out;
    assign B_mux_chk = B_mux_out;
endmodule
\end{verbatim}

\subsubsection{Módulo Controle}
\begin{verbatim}
module GCDcontrol(
    input input_available,
    output reg idle,
    input clk, reset,
    output reg A_ld, B_sel, B_ld,
    output reg [1:0] A_sel,
    input B_zero, A_lt_B,
    output reg result_rdy,
    input result_taken,
    output [1:0] State
);

    // States naming
    localparam WAIT = 2'd0;
    localparam CALC = 2'd1;
    localparam DONE = 2'd2;

    // Constants naming for A_mux selector
    localparam A_SEL_IN = 2'b00;
    localparam A_SEL_SUB = 2'b01;
    localparam A_SEL_B = 2'b10;
    localparam A_SEL_X = 2'b11;
    // Constants naming for B_mux selector
    localparam B_SEL_A = 1'b0;
    localparam B_SEL_IN = 1'b1;
    localparam B_SEL_X = 1'bx;

    reg [1:0] CurrentState, NextState;

    always @(posedge clk or posedge reset)  
    begin 
        if (reset) 
            CurrentState <= WAIT;
        else 
            CurrentState <= NextState; 
    end 

    always @(CurrentState)
    begin
        // default is to stay in the same state
        NextState <= CurrentState;
        case ( CurrentState )
            WAIT :
                if ( input_available )
                    NextState <= CALC;
            CALC :
                if ( B_zero )
                    NextState <= DONE;
            DONE :
                if ( result_taken )
                    NextState <= WAIT;
        endcase
    end 

    always @( * )
    begin
        // Default control signals
        A_sel <= A_SEL_X;
        A_ld <= 1'b0;
        B_sel <= B_SEL_X;
        B_ld <= 1'b0;
        idle <= 1'b0; 
        result_rdy = 1'b0;

        case ( CurrentState )
            WAIT :
                begin
                    idle <= 1'b1; 
                    if(input_available)begin
                        A_sel <= A_SEL_IN;
                        B_sel <= B_SEL_IN;
                        A_ld <= 1'b1;   
                        B_ld <= 1'b1;
                    end
                end
            CALC :
                if ( A_lt_B )begin
                    A_sel <= A_SEL_B;
                    B_sel <= B_SEL_A;
                    A_ld <= 1'b1;
                    B_ld <= 1'b1;
                end
                else if ( !B_zero )begin
                    A_sel <= A_SEL_SUB;
                    A_ld <= 1'b1;
                end
            DONE : 
                result_rdy <= 1'b1;
        endcase
    end

    assign State = CurrentState; 
endmodule
\end{verbatim}

\section{Máquina de Estados Finitos (FSM)}
% Nesta seção, discuta a FSM utilizada para controlar o Datapath.

\subsection{Descrição dos Estados}
% Descrever os diferentes estados da FSM, explicando o que ocorre em cada estado e como as transições entre estados são gerenciadas. Pode incluir um diagrama de estados para visualização.

\subsection{Implementação da FSM}
% Discutir como a FSM foi implementada em Verilog, incluindo os desafios encontrados durante o desenvolvimento e como foram superados. Explicar a lógica de transição e os sinais de controle envolvidos.

\section{Simulações e Verificação}

Para validar a implementação, foi realizada a simulação dos módulos utilizando o ambiente Intel QuestaSim. A Figura \ref{fig:simulacao} mostra a simulação do módulo GCD.

\subsection{Simulação do módulo GCD}
\begin{figure}[ht]
\centering
% \includegraphics[width=10cm,angle=0]{simulacao_gcd.png}
\caption{Simulação do módulo GCD}
\label{fig:simulacao}
\end{figure}

Os resultados da simulação confirmam que o design do GCD em hardware funciona conforme esperado. O módulo datapath executa corretamente as operações de subtração e troca, enquanto o módulo de controle gerencia os estados do sistema de maneira eficiente.

\subsection{Ambiente de Simulação}
% Descrever o ambiente de simulação utilizado, como o Intel QuestaSim. Explicar como os testes foram configurados e quais aspectos do sistema foram verificados.

\subsection{Resultados da Simulação}
% Apresentar os resultados obtidos durante a simulação. Incluir gráficos ou capturas de tela que mostrem a operação do GCD. Discutir se os resultados atenderam às expectativas e os objetivos do projeto.

\section{Otimizações e Melhorias Futuras}
% Discutir possíveis otimizações no design e propostas para futuras melhorias.

\subsection{Otimização do Datapath}
% Sugerir melhorias no Datapath, como a implementação de pipelining para aumentar a eficiência. Discutir possíveis modificações que poderiam ser feitas para melhorar o desempenho geral do sistema.

\subsection{Expansão do Design para Sistemas Maiores}
% Discutir como o design do GCD poderia ser expandido para se integrar com sistemas maiores ou suportar operações mais complexas. Propor ideias para a adaptação do módulo para novas aplicações.

\section{Discussão sobre Integração com Sistemas Maiores}
% Explorar como o módulo GCD poderia ser integrado em sistemas mais complexos, como processadores ou coprocessadores específicos para criptografia. Discutir os desafios de integração e as vantagens dessa abordagem.

\section{Conclusões}

Neste artigo, apresentamos a implementação do algoritmo GCD em hardware, detalhando a modelagem dos módulos de controle e datapath em Verilog. A simulação mostrou que a abordagem utilizada é eficiente e atende aos requisitos do projeto. Futuras melhorias podem incluir a otimização do datapath e a integração com outros módulos de um sistema maior.

%Referências Bibliográficas
\bibliography{bibliografia.bib}
%\printbibliography[title={REFERÊNCIAS}]
%\printbibliography{bibliografia}

\end{document}
